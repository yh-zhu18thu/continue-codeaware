<!-- Generated by SpecStory -->

# 支持多个高亮事件的更新方法 (2025-07-22 01:37Z)

_**User**_

如果我想让updateHighlight同时支持多个highlightevent的更新，需要做哪些更改，有哪些关联的修改？

---

_**Assistant**_

要让 `updateHighlight` 同时支持多个 `HighlightEvent` 的更新，需要进行以下修改：

## 1. 修改 `updateHighlight` reducer

````typescript
// ...existing code...
updateHighlight: (state, action: PayloadAction<HighlightEvent | HighlightEvent[]>) => {
    // 统一处理单个或多个事件
    const events = Array.isArray(action.payload) ? action.payload : [action.payload];
    
    // 清除所有现有高亮
    codeAwareSessionSlice.caseReducers.clearAllHighlights(state);
    
    // 收集所有匹配的mappings
    let allMatchedMappings: CodeAwareMapping[] = [];
    
    events.forEach(({ sourceType, identifier, additionalInfo }) => {
        let matchedMappings: CodeAwareMapping[] = [];
        
        // First, try to match by identifier - collect all matching mappings
        for (const mapping of state.codeAwareMappings) {
            let isMatch = false;
            
            switch (sourceType) {
                case "code":
                    isMatch = mapping.codeChunkId === identifier;
                    break;
                case "requirement":
                    isMatch = mapping.requirementChunkId === identifier;
                    break;
                case "step":
                    isMatch = mapping.stepId === identifier;
                    break;
                case "knowledgeCard":
                    isMatch = mapping.knowledgeCardId === identifier;
                    break;
            }
            
            if (isMatch) {
                matchedMappings.push(mapping);
            }
        }
        
        // If no match found by identifier and sourceType is "code", try meta search
        if (matchedMappings.length === 0 && sourceType === "code" && additionalInfo) {
            const codeInfo = additionalInfo as CodeChunk;
            
            for (const codeChunk of state.codeChunks) {
                const rangesOverlap = (
                    codeInfo.range[0] <= codeChunk.range[1] &&
                    codeInfo.range[1] >= codeChunk.range[0]
                );
                
                const contentMatches = codeChunk.content.includes(codeInfo.content) || 
                                     codeInfo.content.includes(codeChunk.content);
                
                if (rangesOverlap && contentMatches) {
                    const foundMappings = state.codeAwareMappings.filter(mapping => 
                        mapping.codeChunkId === codeChunk.id
                    );
                    matchedMappings.push(...foundMappings);
                }
            }
        }
        
        // 添加到总的匹配列表中，避免重复
        matchedMappings.forEach(mapping => {
            if (!allMatchedMappings.some(m => 
                m.codeChunkId === mapping.codeChunkId &&
                m.requirementChunkId === mapping.requirementChunkId &&
                m.stepId === mapping.stepId &&
                m.knowledgeCardId === mapping.knowledgeCardId
            )) {
                allMatchedMappings.push(mapping);
            }
        });
    });
    
    // 如果找到匹配的mappings，更新所有相关元素的高亮状态
    if (allMatchedMappings.length > 0) {
        // 收集所有唯一的ID
        const codeChunkIds = new Set<string>();
        const requirementChunkIds = new Set<string>();
        const stepIds = new Set<string>();
        const knowledgeCardIds = new Set<string>();

        allMatchedMappings.forEach(mapping => {
            if (mapping.codeChunkId) codeChunkIds.add(mapping.codeChunkId);
            if (mapping.requirementChunkId) requirementChunkIds.add(mapping.requirementChunkId);
            if (mapping.stepId) stepIds.add(mapping.stepId);
            if (mapping.knowledgeCardId) knowledgeCardIds.add(mapping.knowledgeCardId);
        });

        // 收集需要在IDE中高亮的代码块
        const codeChunksForIde: CodeChunk[] = [];

        // 更新代码块高亮
        codeChunkIds.forEach(codeChunkId => {
            const codeChunk = state.codeChunks.find(chunk => chunk.id === codeChunkId);
            if (codeChunk) {
                codeChunk.isHighlighted = true;
                codeChunksForIde.push(codeChunk);
            }
        });

        // 设置IDE高亮
        state.codeChunksToHighlightInIde = codeChunksForIde;
        state.shouldClearIdeHighlights = false;
        
        // 更新需求块高亮
        if (state.userRequirement?.highlightChunks) {
            requirementChunkIds.forEach(requirementChunkId => {
                const reqChunk = state.userRequirement?.highlightChunks?.find(
                    chunk => chunk.id === requirementChunkId
                );
                if (reqChunk) {
                    reqChunk.isHighlighted = true;
                }
            });
        }
        
        // 更新步骤高亮
        stepIds.forEach(stepId => {
            const stepIndex = state.steps.findIndex(step => step.id === stepId);
            if (stepIndex !== -1) {
                state.steps[stepIndex] = {
                    ...state.steps[stepIndex],
                    isHighlighted: true
                };
            }
        });

        // 更新知识卡片高亮
        const hasCodeOrKnowledgeCardSource = events.some(event => 
            event.sourceType === "code" || event.sourceType === "knowledgeCard"
        );
        
        if (hasCodeOrKnowledgeCardSource) {
            knowledgeCardIds.forEach(knowledgeCardId => {
                for (const step of state.steps) {
                    const knowledgeCard = step.knowledgeCards.find(
                        card => card.id === knowledgeCardId
                    );
                    if (knowledgeCard) {
                        knowledgeCard.isHighlighted = true;
                        break;
                    }
                }
            });
        }

        // 更新所有匹配的mappings的高亮状态
        allMatchedMappings.forEach(mapping => {
            mapping.isHighlighted = true;
        });
    }
},
// ...existing code...
````

## 2. 添加批量高亮的便捷 action（可选）

````typescript
// ...existing code...
updateMultipleHighlights: (state, action: PayloadAction<HighlightEvent[]>) => {
    // 直接调用 updateHighlight，它现在已经支持数组
    codeAwareSessionSlice.caseReducers.updateHighlight(state, action);
},
// ...existing code...
````

## 3. 更新类型定义（如果需要）

如果 `HighlightEvent` 类型定义在其他地方，可能需要创建一个联合类型：

````typescript
// 在相关的类型文件中
type HighlightEventPayload = HighlightEvent | HighlightEvent[];
````

## 4. 更新导出的 actions

````typescript
// ...existing code...
export const {
    setUserRequirementStatus,
    submitRequirementContent,
    setGeneratedSteps,
    updateRequirementHighlightChunks,
    toggleRequirementChunkHighlight,
    newCodeAwareSession,
    resetSessionExceptRequirement,
    clearAllHighlights,
    updateHighlight,
    updateMultipleHighlights, // 如果添加了这个action
    updateRequirementChunks,
    updateCodeChunks,
    updateCodeAwareMappings,
    // ...其他actions
} = codeAwareSessionSlice.actions
// ...existing code...
````

## 5. 使用示例

现在你可以这样使用：

````typescript
// 单个高亮事件（保持兼容性）
dispatch(updateHighlight({
    sourceType: "code",
    identifier: "chunk-1",
    additionalInfo: null
}));

// 多个高亮事件
dispatch(updateHighlight([
    {
        sourceType: "code",
        identifier: "chunk-1",
        additionalInfo: null
    },
    {
        sourceType: "step",
        identifier: "step-2",
        additionalInfo: null
    },
    {
        sourceType: "requirement",
        identifier: "req-3",
        additionalInfo: null
    }
]));
````

## 主要改进点

1. **向后兼容**：现有的单个事件调用仍然有效
2. **性能优化**：只执行一次清除操作和一次高亮更新
3. **去重处理**：避免重复处理相同的mapping
4. **统一逻辑**：多个事件共享相同的匹配和高亮逻辑
5. **类型安全**：通过 TypeScript 确保类型正确性

这种实现方式确保了代码的可维护性和性能，同时保持了与现有代码的兼容性。

---

_**User**_

请使用具有兼容性的方式修改一下updateHighlight，使其同时支持单个或多个highlightevent触发

---

_**Assistant**_

我将修改 `updateHighlight` 函数，使其既支持单个 `HighlightEvent` 也支持 `HighlightEvent[]`，并保持向后兼容性。 

---

