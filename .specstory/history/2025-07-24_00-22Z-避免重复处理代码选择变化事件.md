<!-- Generated by SpecStory -->

# 避免重复处理代码选择变化事件 (2025-07-24 00:22Z)

_**User**_

当ide中代码选择的内容变化的时候，会发送多个同样的codeSelectionChanged，我该如何避免反复处理一样的事件？

---

_**Assistant**_

你可以通过以下几种方式来避免反复处理相同的 `codeSelectionChanged` 事件：

## 方法一：在发送端进行防抖处理

在 `VsCodeExtension.ts` 中添加防抖逻辑：

````typescript
export class VsCodeExtension {
  // ...existing code...
  private lastSelectionData: any = null;
  private selectionDebounceTimer: NodeJS.Timeout | null = null;

  constructor(context: vscode.ExtensionContext) {
    // ...existing code...

    // CodeAware: 监听代码选择变化
    vscode.window.onDidChangeTextEditorSelection(async (event) => {
      const editor = event.textEditor;
      const document = editor.document;
      
      // 确保这是一个有效的文本文档
      if (document.uri.scheme !== 'file') {
        return;
      }

      const selection = event.selections[0]; // 取第一个选择区域

      // 只处理有选中内容的情况
      if (!selection.isEmpty) {
        const startLine = selection.start.line + 1;
        const endLine = selection.end.line + 1;
        const selectedContent = document.getText(selection);

        const currentSelectionData = {
          filePath: document.uri.fsPath,
          selectedLines: [startLine, endLine],
          selectedContent,
        };

        // 检查是否与上次选择相同
        if (this.isSameSelection(currentSelectionData, this.lastSelectionData)) {
          return;
        }

        // 清除之前的定时器
        if (this.selectionDebounceTimer) {
          clearTimeout(this.selectionDebounceTimer);
        }

        // 设置新的防抖定时器
        this.selectionDebounceTimer = setTimeout(async () => {
          this.lastSelectionData = currentSelectionData;
          const webviewProtocol = await this.webviewProtocolPromise;
          void webviewProtocol.request("codeSelectionChanged", currentSelectionData);
        }, 150); // 150ms 防抖延迟
      }
    });

    // ...existing code...
  }

  private isSameSelection(current: any, previous: any): boolean {
    if (!previous) return false;
    
    return current.filePath === previous.filePath &&
           current.selectedLines[0] === previous.selectedLines[0] &&
           current.selectedLines[1] === previous.selectedLines[1] &&
           current.selectedContent === previous.selectedContent;
  }
}
````

## 方法二：在接收端进行去重处理

在 `useSetup.ts` 中添加去重逻辑：

````typescript
function useSetup() {
  // ...existing code...
  
  // 添加用于跟踪上次处理的选择的 ref
  const lastProcessedSelectionRef = useRef<{
    filePath: string;
    selectedLines: number[];
    selectedContent: string;
  } | null>(null);

  // CodeAware: 监听代码选择变化事件
  useWebviewListener("codeSelectionChanged", async (data) => {
    const { filePath, selectedLines, selectedContent } = data;

    // 检查是否与上次处理的选择相同
    const lastProcessed = lastProcessedSelectionRef.current;
    if (lastProcessed &&
        lastProcessed.filePath === filePath &&
        lastProcessed.selectedLines[0] === selectedLines[0] &&
        lastProcessed.selectedLines[1] === selectedLines[1] &&
        lastProcessed.selectedContent === selectedContent) {
      return; // 跳过重复的事件
    }

    // 更新上次处理的选择
    lastProcessedSelectionRef.current = { filePath, selectedLines, selectedContent };

    // 查找与选中范围重叠最多的 CodeChunk
    let bestMatch = null;
    let maxOverlapLines = 0;

    for (const chunk of codeChunks) {
      // 如果 CodeChunk 的文件路径不匹配，跳过
      if (chunk.filePath !== filePath) {
        continue;
      }
      // 计算重叠的行数
      const overlapStart = Math.max(selectedLines[0], chunk.range[0]);
      const overlapEnd = Math.min(selectedLines[1], chunk.range[1]);
      const overlapLines = overlapEnd - overlapStart + 1;

      // 至少有一行重叠且重叠行数最多
      if (overlapLines > 0 && overlapLines > maxOverlapLines) {
        maxOverlapLines = overlapLines;
        bestMatch = chunk;
      }
    }

    // 如果找到最佳匹配的 CodeChunk，触发高亮更新
    if (bestMatch) {
      dispatch(
        updateHighlight({
          sourceType: "code",
          identifier: bestMatch.id,
          additionalInfo: bestMatch,
        }),
      );
    }

    // 发送调试信息到控制台
    console.log("Code Selection Changed:", {
      filePath,
      selectedLines,
      selectedContent: selectedContent.substring(0, 100) + "...", // 只显示前100个字符
      bestMatchId: bestMatch?.id || null,
      maxOverlapLines,
      CodeChunks: codeChunks,
    });
  }, [codeChunks, dispatch]);

  // ...existing code...
}
````

## 推荐方案

我建议使用**方法一（发送端防抖）**，因为：

1. **性能更好**：在源头就减少了不必要的消息传递
2. **更符合逻辑**：防止在用户快速选择时产生大量事件
3. **减少网络开销**：避免webview和extension之间的重复通信

防抖延迟设置为 150ms 是一个比较合适的值，既能避免重复事件，又不会让用户感觉到明显的延迟。你可以根据实际体验调整这个值。

---

_**User**_

我注意到由于用户在选择多行的过程中选区会不断变化直至稳定，该如何只发送一次稳定的事件

---

_**Assistant**_

你需要在类中添加防抖相关的属性，并修改代码选择监听逻辑。以下是具体的实现：

````typescript
export class VsCodeExtension {
  // Currently some of these are public so they can be used in testing (test/test-suites)

  private configHandler: ConfigHandler;
  private extensionContext: vscode.ExtensionContext;
  private ide: VsCodeIde;
  private sidebar: ContinueGUIWebviewViewProvider;
  private windowId: string;
  private editDecorationManager: EditDecorationManager;
  private highlightCodeManager: HighlightCodeManager;
  private verticalDiffManager: VerticalDiffManager;
  webviewProtocolPromise: Promise<VsCodeWebviewProtocol>;
  private core: Core;
  private battery: Battery;
  private workOsAuthProvider: WorkOsAuthProvider;
  private fileSearch: FileSearch;
  // private metacompleteProvider: MetaCompleteProvider;
  
  // CodeAware: 添加防抖相关属性
  private lastSelectionData: {
    filePath: string;
    selectedLines: number[];
    selectedContent: string;
  } | null = null;
  private selectionDebounceTimer: NodeJS.Timeout | null = null;

  constructor(context: vscode.ExtensionContext) {
    // ...existing code...

    // CodeAware: 监听代码选择变化
    vscode.window.onDidChangeTextEditorSelection(async (event) => {
      const editor = event.textEditor;
      const document = editor.document;
      
      // 确保这是一个有效的文本文档
      if (document.uri.scheme !== 'file') {
        return;
      }

      const selection = event.selections[0]; // 取第一个选择区域

      // 只处理有选中内容的情况
      if (!selection.isEmpty) {
        const startLine = selection.start.line + 1;
        const endLine = selection.end.line + 1;
        const selectedContent = document.getText(selection);

        const currentSelectionData = {
          filePath: document.uri.fsPath,
          selectedLines: [startLine, endLine],
          selectedContent,
        };

        // 检查是否与上次选择相同
        if (this.isSameSelection(currentSelectionData, this.lastSelectionData)) {
          return;
        }

        // 清除之前的定时器
        if (this.selectionDebounceTimer) {
          clearTimeout(this.selectionDebounceTimer);
        }

        // 设置新的防抖定时器
        this.selectionDebounceTimer = setTimeout(async () => {
          this.lastSelectionData = currentSelectionData;
          const webviewProtocol = await this.webviewProtocolPromise;
          void webviewProtocol.request("codeSelectionChanged", currentSelectionData);
        }, 300); // 300ms 防抖延迟，适合多行选择场景
      } else {
        // 如果没有选中内容，清除防抖定时器和上次选择数据
        if (this.selectionDebounceTimer) {
          clearTimeout(this.selectionDebounceTimer);
          this.selectionDebounceTimer = null;
        }
        this.lastSelectionData = null;
      }
    });

    // ...existing code...
  }

  // ...existing code...

  private isSameSelection(
    current: { filePath: string; selectedLines: number[]; selectedContent: string },
    previous: { filePath: string; selectedLines: number[]; selectedContent: string } | null
  ): boolean {
    if (!previous) return false;
    
    return current.filePath === previous.filePath &&
           current.selectedLines[0] === previous.selectedLines[0] &&
           current.selectedLines[1] === previous.selectedLines[1] &&
           current.selectedContent === previous.selectedContent;
  }
}
````

关键改进点：

1. **添加类属性**：
   - `lastSelectionData`: 存储上次处理的选择数据
   - `selectionDebounceTimer`: 防抖定时器

2. **防抖逻辑**：
   - 每次选择变化时先清除之前的定时器
   - 设置新的300ms延迟定时器
   - 只有在300ms内没有新的选择变化时才发送事件

3. **去重检查**：
   - 比较文件路径、选择行范围和选择内容
   - 如果与上次完全相同则不处理

4. **处理空选择**：
   - 当用户取消选择时，清除定时器和缓存数据

5. **防抖延迟调整**：
   - 300ms 比较适合多行选择场景，既能避免频繁触发，又不会让用户感觉到明显延迟

这样就能确保只在用户完成稳定选择后发送一次事件，避免在选择过程中的中间状态触发多次处理。

---

_**User**_

好的，那请在ide端添加这些防抖、去重和空选择的处理机制

---

_**Assistant**_

我来帮你在IDE端添加防抖、去重和空选择的处理机制。

首先，我需要在类中添加防抖相关的属性： 
```

```
接下来，我需要替换现有的代码选择监听逻辑，添加防抖和去重处理： 
```

```
现在我需要添加 `isSameSelection` 方法，并修复类型问题： 
```

```
现在添加 `isSameSelection` 方法： 

---

