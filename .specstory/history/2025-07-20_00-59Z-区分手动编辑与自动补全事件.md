<!-- Generated by SpecStory -->

# 区分手动编辑与自动补全事件 (2025-07-20 00:59Z)

_**User**_

我希望在这里获取到editor中最新的编辑事件，同时希望知道这个编辑事件是由人手动编辑的，还是自动补全的

---

_**Assistant**_

基于你的需求，我建议在构造函数中添加对编辑事件的监听。这里有几种方法来区分手动编辑和自动补全：

````typescript
// ...existing code...

    this.metacompleteProvider = new MetaCompleteProvider(context, this.ide, this.configHandler);

    // CodeAware: 监听文档内容变化事件
    let isAutoCompletion = false;
    
    // 监听补全事件
    vscode.languages.onDidTriggerInlineCompletion(() => {
      isAutoCompletion = true;
      // 设置一个短暂的延时重置标志
      setTimeout(() => {
        isAutoCompletion = false;
      }, 100);
    });

    // 监听文档变化事件
    vscode.workspace.onDidChangeTextDocument(async (event) => {
      const document = event.document;
      
      // 确保这是一个有效的文件文档
      if (document.uri.scheme !== 'file') {
        return;
      }

      const webviewProtocol = await this.webviewProtocolPromise;
      
      // 分析变化类型
      for (const change of event.contentChanges) {
        const changeInfo = {
          filePath: document.uri.fsPath,
          range: {
            start: {
              line: change.range.start.line + 1,
              character: change.range.start.character + 1
            },
            end: {
              line: change.range.end.line + 1,
              character: change.range.end.character + 1
            }
          },
          text: change.text,
          rangeLength: change.rangeLength,
          isAutoCompletion: isAutoCompletion,
          timestamp: Date.now()
        };

        void webviewProtocol.request("documentContentChanged", changeInfo);
      }
    });

    // 更精确的方法：监听命令执行来检测自动补全
    const commandDisposable = vscode.commands.registerCommand('continue.trackAutoCompletion', () => {
      isAutoCompletion = true;
      setTimeout(() => {
        isAutoCompletion = false;
      }, 200);
    });
    context.subscriptions.push(commandDisposable);
  }
// ...existing code...
````

如果你需要更精确的检测方法，可以结合以下几种策略：

````typescript
// ...existing code...

    // CodeAware: 更精确的编辑事件检测
    let lastCompletionTime = 0;
    let isTyping = false;
    
    // 监听键盘输入事件
    vscode.window.onDidChangeActiveTextEditor((editor) => {
      if (editor) {
        // 监听编辑器的输入事件
        const disposable = vscode.commands.registerTextEditorCommand(
          'type', 
          () => {
            isTyping = true;
            setTimeout(() => {
              isTyping = false;
            }, 50);
          }
        );
        context.subscriptions.push(disposable);
      }
    });

    // 监听补全接受事件
    vscode.commands.registerCommand('continue.onCompletionAccepted', () => {
      lastCompletionTime = Date.now();
    });

    vscode.workspace.onDidChangeTextDocument(async (event) => {
      const document = event.document;
      
      if (document.uri.scheme !== 'file') {
        return;
      }

      const webviewProtocol = await this.webviewProtocolPromise;
      const currentTime = Date.now();
      
      // 判断编辑类型的多种方法
      const isLikelyAutoCompletion = 
        // 方法1: 基于时间判断
        (currentTime - lastCompletionTime < 500) ||
        // 方法2: 基于变化特征判断
        event.contentChanges.some(change => 
          change.text.length > 10 && // 长文本插入
          !change.text.includes('\n') && // 单行插入
          change.rangeLength === 0 // 纯插入操作
        ) ||
        // 方法3: 基于变化速度判断
        (!isTyping && event.contentChanges.length === 1);

      for (const change of event.contentChanges) {
        const changeInfo = {
          filePath: document.uri.fsPath,
          range: {
            start: {
              line: change.range.start.line + 1,
              character: change.range.start.character + 1
            },
            end: {
              line: change.range.end.line + 1,
              character: change.range.end.character + 1
            }
          },
          text: change.text,
          rangeLength: change.rangeLength,
          isManualEdit: isTyping,
          isLikelyAutoCompletion: isLikelyAutoCompletion,
          changeType: change.rangeLength === 0 ? 'insert' : 
                     change.text === '' ? 'delete' : 'replace',
          timestamp: currentTime
        };

        void webviewProtocol.request("documentEditEvent", changeInfo);
      }
    });
// ...existing code...
````

这两种方法提供了不同程度的检测精度：

1. **第一种方法**更简单，基于补全事件的时间窗口来判断
2. **第二种方法**更复杂但更准确，结合多种特征来判断编辑类型

你可以根据具体需求选择合适的方法，或者两种方法结合使用来获得最佳的检测效果。

---

