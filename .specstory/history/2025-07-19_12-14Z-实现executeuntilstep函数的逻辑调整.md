<!-- Generated by SpecStory -->

# 实现executeUntilStep函数的逻辑调整 (2025-07-19 12:14Z)

_**User**_

在executeUntilStep中首先根据step_id从codeAwareSlice中获取截止step_id所有未执行步骤的title, abstract和id信息，同时也要包括这些step中的知识点卡片标题和id，调整codeAwareSlice中的selectGenerationContextUntilStep函数的实现。与此同时，需要通过ideMessenger调用getCurrentFile获取当前文件中的所有代码，之后的逻辑todo

---

_**Assistant**_

根据你的需求，我需要修改 `executeUntilStep` 函数和 `selectGenerationContextUntilStep` 选择器。让我来实现这些改动：

````typescript
// ...existing code...
const executeUntilStep = useCallback(async (stepId: string) => {
  console.log(`执行到步骤: ${stepId}`);
  
  // 从Redux获取截止到stepId的生成上下文
  const generationContext = useAppSelector(state => 
    selectGenerationContextUntilStep(state.codeAwareSession, stepId)
  );
  
  if (!generationContext) {
    console.error('无法获取生成上下文');
    return;
  }
  
  try {
    // 通过ideMessenger获取当前文件的代码
    const currentFile = await ideMessenger?.request("getCurrentFile", {});
    
    console.log('生成上下文:', generationContext);
    console.log('当前文件:', currentFile);
    
    // TODO: 实现后续的逻辑
    // 1. 将生成上下文和当前文件代码发送给AI
    // 2. 处理AI的响应
    // 3. 更新相关步骤的状态
    
  } catch (error) {
    console.error('获取当前文件失败:', error);
  }
}, [ideMessenger]);
// ...existing code...
````

````typescript
// ...existing code...
selectGenerationContextUntilStep: (state: CodeAwareSessionState, stepId: string) => {
  // 获取当前步骤之前所有的未执行步骤（stepstatus==confirmed或editing）
  const targetStepIndex = state.steps.findIndex(step => step.id === stepId);
  if (targetStepIndex === -1) {
    return null; // 如果没有找到该步骤，则返回null
  }
  
  // 找到第一个需要执行的步骤（confirmed或editing状态）
  const firstUnexecutedIndex = state.steps.findIndex(step => 
    step.stepStatus === "confirmed" || step.stepStatus === "editing"
  );
  
  if (firstUnexecutedIndex === -1 || firstUnexecutedIndex > targetStepIndex) {
    return null; // 如果没有找到需要执行的步骤，或者第一个需要执行的步骤在目标步骤之后，则返回null
  }
  
  // 获取从第一个未执行步骤到目标步骤的所有步骤
  const stepsToExecute = state.steps.slice(firstUnexecutedIndex, targetStepIndex + 1);
  
  // 构建包含步骤信息和知识卡片信息的上下文
  const stepsWithKnowledgeCards = stepsToExecute.map((step, index) => {
    const stepNumber = firstUnexecutedIndex + index + 1;
    
    // 获取该步骤的知识卡片信息
    const knowledgeCardsInfo = step.knowledgeCards.map(card => ({
      id: card.id,
      title: card.title,
      disabled: card.disabled || false
    }));
    
    return {
      stepNumber,
      id: step.id,
      title: step.title,
      abstract: cleanMarkdownText(step.abstract),
      stepStatus: step.stepStatus,
      knowledgeCards: knowledgeCardsInfo
    };
  });
  
  return {
    userRequirement: state.userRequirement?.requirementDescription || "",
    targetStepId: stepId,
    targetStepTitle: state.steps[targetStepIndex].title,
    stepsToExecute: stepsWithKnowledgeCards,
    totalStepsCount: stepsToExecute.length
  } as GenerationContext;
},
// ...existing code...
````

````typescript
// 需要更新 GenerationContext 类型定义
export interface GenerationContext {
  userRequirement: string;
  targetStepId: string;
  targetStepTitle: string;
  stepsToExecute: Array<{
    stepNumber: number;
    id: string;
    title: string;
    abstract: string;
    stepStatus: StepStatus;
    knowledgeCards: Array<{
      id: string;
      title: string;
      disabled: boolean;
    }>;
  }>;
  totalStepsCount: number;
}
````

主要改动说明：

1. **修改了 `executeUntilStep` 函数**：
   - 使用 `useAppSelector` 获取生成上下文
   - 通过 `ideMessenger.request("getCurrentFile")` 获取当前文件代码
   - 添加了错误处理
   - 为后续逻辑预留了 TODO 注释

2. **重新实现了 `selectGenerationContextUntilStep` 选择器**：
   - 获取从第一个未执行步骤到目标步骤的所有步骤
   - 包含每个步骤的详细信息：编号、ID、标题、摘要、状态
   - 包含每个步骤的知识卡片信息：ID、标题、是否禁用
   - 返回结构化的生成上下文

3. **更新了 `GenerationContext` 类型**：
   - 添加了 `targetStepId` 和 `targetStepTitle`
   - 用 `stepsToExecute` 数组替换了原来的 `orderedSteps` 字符串
   - 包含了知识卡片的详细信息
   - 添加了 `totalStepsCount` 用于统计

这样的实现提供了更丰富的上下文信息，便于后续的AI处理和步骤执行逻辑。

---

