<!-- Generated by SpecStory -->

# 计算与选中范围重叠最多的 CodeChunk (2025-07-20 01:15Z)

_**User**_

我希望计算所有的codechunks和selected的范围重叠最多的一个（且至少有一行重叠），然后去找更新这个codechunk所应该触发的高亮

---

_**Assistant**_

我来帮你修改代码，计算与选中范围重叠最多的 CodeChunk 并触发相应的高亮更新：

````typescript
// CodeAware: 监听代码选择变化事件
useWebviewListener("codeSelectionChanged", async (data) => {
  const { filePath, selectedLines, selectedContent } = data;

  // 查找与选中范围重叠最多的 CodeChunk
  let bestMatch = null;
  let maxOverlapLines = 0;

  for (const chunk of codeChunks) {
    // 检查文件路径是否匹配
    if (chunk.filePath === filePath) {
      // 计算重叠的行数
      const overlapStart = Math.max(selectedLines[0], chunk.range[0]);
      const overlapEnd = Math.min(selectedLines[1], chunk.range[1]);
      const overlapLines = overlapEnd - overlapStart + 1;

      // 至少有一行重叠且重叠行数最多
      if (overlapLines > 0 && overlapLines > maxOverlapLines) {
        maxOverlapLines = overlapLines;
        bestMatch = chunk;
      }
    }
  }

  // 如果找到最佳匹配的 CodeChunk，触发高亮更新
  if (bestMatch) {
    dispatch(
      updateHighlight({
        sourceType: "code",
        identifier: bestMatch.id,
        additionalInfo: bestMatch,
      }),
    );
  }

  // 发送调试信息到控制台
  console.log("Code Selection Changed:", {
    filePath,
    selectedLines,
    selectedContent: selectedContent.substring(0, 100) + "...", // 只显示前100个字符
    bestMatchId: bestMatch?.id || null,
    maxOverlapLines,
    totalCodeChunks: codeChunks.length,
  });
}, [codeChunks, dispatch]);
````

主要改进：

1. **计算重叠行数**：使用 `Math.max` 和 `Math.min` 来计算实际重叠的行数范围
2. **找到最佳匹配**：遍历所有符合条件的 CodeChunk，记录重叠行数最多的那个
3. **确保至少一行重叠**：只有当 `overlapLines > 0` 时才认为是有效匹配
4. **单一高亮更新**：只为最佳匹配的 CodeChunk 触发一次高亮更新
5. **改进调试信息**：显示最佳匹配的 ID 和重叠行数，便于调试

这样修改后，系统会精确地找到与用户选中代码重叠最多的 CodeChunk，并只为该 CodeChunk 触发高亮更新。

---

