<!-- Generated by SpecStory -->

# 处理代码变更时的步骤更新逻辑 (2025-07-29 01:19Z)

_**User**_

我现在需要处理从codeEditorMode切换回CodeAwareOnlyMode时的逻辑，在processCodeChange中，当检测到有代码实质变更，并且把对应的step设置成code_dirty后，CodeAware界面应该根据是否有任何步骤处于code_dirty状态来设置Loading Overlay. 然后继续processCodeChanges的逻辑。对于code_dirty的步骤，将步骤和其下的知识卡片涉及的code_chunks都disable掉，把涉及这部分的mapping删除掉。只要有任何步骤为code_dirty，都需要调用一个llm更新的thunks。样例输入为{
   "current_code":"df = pd.read_csv(csv_filename)\n\nprint(\"数据集概览:\")\nprint(\"\n标签分布:\")\n print(df['label'].value_counts())\nprint(df.head())\n\n# 删除包含任何缺失值的行\ndf.dropna(inplace=True)",
   "code_diff":"+ print("\n标签分布:") + print(df['label'].value_counts())"
   "relevant_steps":[
       {
           "id":"s-2",
           "title":"查看数据的样式",
           "abstract":"读入数据后，可以去查看一下数据的格式并保证读取正确性。使用筛选表格前几行的方法（head函数）采样表格数据，并打印出来"，
           "knowledge_cards":[{
               "id":"s-2-kc-1",
               "title":"查看数据表格的目的"
           }]
}，样例输出为：{
    "updated_steps":[{
         "id":"s-2",
        "needs_update":true,
         "title":"查看数据的样式和标签分布"，
         "abstract":"读入数据后，可以去查看一下数据的格式和标签的分布来判断数据的质量。使用筛选表格前几行的方法（head函数）采样表格数据，并打印出来。然后用value_counts来打印表格中label列的取值统计",
         "corresponding_code":"df = pd.read_csv(csv_filename)\n\nprint(\"数据集概览:\")\nprint(\"\n标签分布:\")\n print(df['label'].value_counts())\nprint(df.head())\n\n# 删除包含任何缺失值的行\ndf.dropna(inplace=True)"
     }],
         "knowledge_cards":[
             {
             "id":"s-2-kc-1",           "needs_update":true,
                 "title":"查看数据取值范围的目的",         "corresponding_code":"print(df['label'].value_counts())"  
             }
         ]
}。这个thunk用来判断发生的更改是否要调整，输入为更新后的代码，code diff(用diff字符串形式表示)，以及发生了修改的相关的步骤信息列表，包括步骤id，步骤标题，步骤摘要，其下的知识卡片id和标题，输出内容包括这些步骤的是否需要更新的信息，通过needs_update表示步骤的abstract和knowledge content是否要更新（无论是否更新内容都需要包括进来，因为需要更新对应的代码区域）如果某个step内容需要更新，则update title和abstract。如果某个knowledge card needs update，则将title更新好后，去掉原来可能已生成的content和question信息。并且指出更新后的步骤/知识卡片对应的当前代码，参考生成代码时计算代码位置的方法添加新的code chunk并创建mapping。

---

_**Assistant**_

我来帮你实现从代码编辑模式切换回CodeAware模式时的完整逻辑。首先需要添加新的thunk来处理代码变更的更新，然后修改现有的`processCodeChanges`逻辑。

## 1. 首先添加新的thunk来处理代码变更更新

````typescript
// ...existing code...

// 异步处理代码变更并更新相关步骤
export const updateStepsFromCodeChanges = createAsyncThunk<
    void,
    {
        currentCode: string;
        codeDiff: string;
        relevantSteps: Array<{
            id: string;
            title: string;
            abstract: string;
            knowledgeCards: Array<{
                id: string;
                title: string;
            }>;
        }>;
    },
    ThunkApiType
>(
    "codeAware/updateStepsFromCodeChanges",
    async (
        { currentCode, codeDiff, relevantSteps },
        { dispatch, extra, getState }
    ) => {
        try {
            const state = getState();
            const defaultModel = selectDefaultModel(state);
            if (!defaultModel) {
                throw new Error("Default model not defined");
            }

            console.log("updateStepsFromCodeChanges called with:", {
                currentCodeLength: currentCode.length,
                codeDiffLength: codeDiff.length,
                relevantStepsCount: relevantSteps.length,
                relevantSteps: relevantSteps.map(s => ({ id: s.id, title: s.title }))
            });

            // 构造提示词
            const prompt = constructUpdateStepsFromCodeChangesPrompt(currentCode, codeDiff, relevantSteps);

            const result = await extra.ideMessenger.request("llm/complete", {
                prompt: prompt,
                completionOptions: {},
                title: defaultModel.title
            });

            if (result.status !== "success" || !result.content) {
                throw new Error("LLM request failed or returned empty content");
            }

            console.log("LLM response for code changes update:", result.content);

            // 解析 LLM 返回的 JSON 内容
            try {
                const jsonResponse = JSON.parse(result.content);
                const updatedSteps = jsonResponse.updated_steps || [];
                const knowledgeCards = jsonResponse.knowledge_cards || [];

                console.log("✅ 代码变更更新成功:", {
                    updatedStepsCount: updatedSteps.length,
                    knowledgeCardsCount: knowledgeCards.length
                });

                // 获取当前状态
                const currentState = getState();
                const currentFilePath = await getCurrentFilePath(extra.ideMessenger);
                const existingCodeChunksCount = currentState.codeAwareSession.codeChunks.length;
                let codeChunkCounter = existingCodeChunksCount + 1;

                // 处理更新的步骤
                for (const stepUpdate of updatedSteps) {
                    const stepId = stepUpdate.id;
                    
                    if (stepUpdate.needs_update) {
                        // 更新步骤标题和摘要
                        if (stepUpdate.title) {
                            dispatch(setStepTitle({ stepId, title: stepUpdate.title }));
                        }
                        if (stepUpdate.abstract) {
                            dispatch(setStepAbstract({ stepId, abstract: stepUpdate.abstract }));
                        }
                        
                        console.log(`📝 更新步骤 ${stepId}:`, {
                            title: stepUpdate.title,
                            abstract: stepUpdate.abstract?.substring(0, 100) + "..."
                        });
                    }

                    // 处理步骤对应的代码
                    if (stepUpdate.corresponding_code && stepUpdate.corresponding_code.trim()) {
                        const stepCodeContent = stepUpdate.corresponding_code.trim();
                        const stepRange = calculateCodeChunkRange(currentCode, stepCodeContent);
                        const stepCodeChunkId = `c-${codeChunkCounter++}`;
                        
                        // 创建新的代码块
                        dispatch(createOrGetCodeChunk({
                            content: stepCodeContent,
                            range: stepRange,
                            filePath: currentFilePath,
                            id: stepCodeChunkId
                        }));

                        // 找到对应的需求块ID（从现有映射中查找）
                        const existingStepMapping = currentState.codeAwareSession.codeAwareMappings.find(
                            mapping => mapping.stepId === stepId && mapping.requirementChunkId
                        );
                        const requirementChunkId = existingStepMapping?.requirementChunkId;

                        // 创建步骤映射
                        dispatch(createCodeAwareMapping({
                            codeChunkId: stepCodeChunkId,
                            stepId: stepId,
                            requirementChunkId: requirementChunkId,
                            isHighlighted: false
                        }));
                        
                        console.log(`🔗 为步骤 ${stepId} 创建新代码块: ${stepCodeChunkId} (${stepRange[0]}-${stepRange[1]}行)`);
                    }
                }

                // 处理知识卡片更新
                for (const cardUpdate of knowledgeCards) {
                    const cardId = cardUpdate.id;
                    const stepId = cardId.split('-kc-')[0]; // 从卡片ID提取步骤ID
                    
                    if (cardUpdate.needs_update) {
                        // 更新知识卡片标题并清空内容
                        if (cardUpdate.title) {
                            dispatch(updateKnowledgeCardTitle({
                                stepId: stepId,
                                cardId: cardId,
                                title: cardUpdate.title
                            }));
                            
                            console.log(`🏷️ 更新知识卡片 ${cardId} 标题: "${cardUpdate.title}"`);
                        }
                    }

                    // 处理知识卡片对应的代码
                    if (cardUpdate.corresponding_code && cardUpdate.corresponding_code.trim()) {
                        const cardCodeContent = cardUpdate.corresponding_code.trim();
                        const cardRange = calculateCodeChunkRange(currentCode, cardCodeContent);
                        const cardCodeChunkId = `c-${codeChunkCounter++}`;
                        
                        // 创建新的代码块
                        dispatch(createOrGetCodeChunk({
                            content: cardCodeContent,
                            range: cardRange,
                            filePath: currentFilePath,
                            id: cardCodeChunkId
                        }));

                        // 找到对应的需求块ID
                        const existingCardMapping = currentState.codeAwareSession.codeAwareMappings.find(
                            mapping => mapping.knowledgeCardId === cardId
                        );
                        const requirementChunkId = existingCardMapping?.requirementChunkId;

                        // 创建知识卡片映射
                        dispatch(createCodeAwareMapping({
                            codeChunkId: cardCodeChunkId,
                            stepId: stepId,
                            knowledgeCardId: cardId,
                            requirementChunkId: requirementChunkId,
                            isHighlighted: false
                        }));
                        
                        console.log(`🎯 为知识卡片 ${cardId} 创建新代码块: ${cardCodeChunkId} (${cardRange[0]}-${cardRange[1]}行)`);
                    }
                }

                // 将所有处理过的步骤状态从 code_dirty 改为 confirmed
                const processedStepIds = updatedSteps.map(step => step.id);
                for (const stepId of processedStepIds) {
                    dispatch(setStepStatus({ stepId, status: "confirmed" }));
                }

                console.log("✅ 代码变更更新完成");

            } catch (parseError) {
                console.error("Error parsing LLM response:", parseError);
                throw new Error("解析LLM响应失败");
            }

        } catch (error) {
            console.error("Error during code changes update:", error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new Error(`代码变更更新失败: ${errorMessage}`);
        }
    }
);

// 辅助函数：获取当前文件路径
async function getCurrentFilePath(ideMessenger: any): Promise<string> {
    try {
        const currentFileResponse = await ideMessenger.request("getCurrentFile", undefined);
        if (currentFileResponse?.status === "success" && currentFileResponse.content) {
            return currentFileResponse.content.path || "";
        }
    } catch (error) {
        console.warn("⚠️ 无法获取当前文件路径:", error);
    }
    return "";
}

// ...existing code...
````

## 2. 添加构造提示词的函数（需要在core/llm/codeAwarePrompts中添加）

你需要在core包中添加这个函数：

````typescript
// ...existing code...

export function constructUpdateStepsFromCodeChangesPrompt(
    currentCode: string,
    codeDiff: string,
    relevantSteps: Array<{
        id: string;
        title: string;
        abstract: string;
        knowledgeCards: Array<{
            id: string;
            title: string;
        }>;
    }>
): string {
    return `你是一个代码学习助手。用户在代码编辑器中修改了代码，现在需要你分析这些变更是否影响相关的学习步骤和知识卡片，并进行相应的更新。

## 当前完整代码：
\`\`\`
${currentCode}
\`\`\`

## 代码变更（diff格式）：
\`\`\`
${codeDiff}
\`\`\`

## 受影响的相关步骤：
${relevantSteps.map(step => `
### 步骤 ${step.id}
- 标题: ${step.title}
- 摘要: ${step.abstract}
- 知识卡片:
${step.knowledgeCards.map(kc => `  - ${kc.id}: ${kc.title}`).join('\n')}
`).join('\n')}

## 任务要求：
请分析代码变更对这些步骤的影响，并返回JSON格式的更新信息：

1. 对于每个步骤，判断是否需要更新其标题和摘要
2. 对于每个知识卡片，判断是否需要更新其标题
3. 为每个步骤和知识卡片确定其对应的代码片段

## 返回格式：
\`\`\`json
{
    "updated_steps": [
        {
            "id": "步骤ID",
            "needs_update": true/false,
            "title": "更新后的标题（如果需要更新）",
            "abstract": "更新后的摘要（如果需要更新）",
            "corresponding_code": "该步骤对应的代码片段"
        }
    ],
    "knowledge_cards": [
        {
            "id": "知识卡片ID", 
            "needs_update": true/false,
            "title": "更新后的标题（如果需要更新）",
            "corresponding_code": "该知识卡片对应的代码片段"
        }
    ]
}
\`\`\`

注意事项：
- 即使不需要更新内容，也要包含在结果中，因为需要更新代码对应关系
- 如果代码变更较小且不影响步骤本质，可以设置 needs_update 为 false
- corresponding_code 应该是从当前完整代码中提取的相关片段
- 更新的标题和摘要应该准确反映代码变更
`;
}

// ...existing code...
````

## 3. 修改processCodeChanges函数

````typescript
// ...existing code...

// Process code changes when exiting code edit mode
export const processCodeChanges = createAsyncThunk<
    void,
    {
        currentFilePath: string;
        currentContent: string;
    },
    ThunkApiType
>(
    "codeAware/processCodeChanges",
    async ({ currentFilePath, currentContent }, { getState, dispatch }) => {
        try {
            const state = getState();
            const snapshot = state.codeAwareSession.codeEditModeSnapshot;
            
            if (!snapshot) {
                console.warn("No code snapshot found, cannot process changes");
                return;
            }

            // Check if we're working on the same file
            if (snapshot.filePath !== currentFilePath) {
                console.warn("File path changed, processing changes might not be accurate");
            }

            // Import diff library dynamically to avoid bundling issues
            const { diffLines } = await import('diff');
            
            // Calculate diff between snapshot and current content
            const changes = diffLines(snapshot.content, currentContent);
            
            console.log("📊 Code changes detected:", {
                totalChanges: changes.length,
                additions: changes.filter(c => c.added).length,
                deletions: changes.filter(c => c.removed).length
            });

            // Track real edits (excluding whitespace-only changes)
            const realEdits: Array<{
                type: 'added' | 'removed' | 'modified';
                lineStart: number;
                lineEnd: number;
                content: string;
            }> = [];

            let currentLine = 1;
            
            for (const change of changes) {
                if (!change.value) continue;
                
                const lines = change.value.split('\n');
                // Remove last empty line if it exists
                if (lines[lines.length - 1] === '') {
                    lines.pop();
                }
                
                if (change.added) {
                    // Check if the addition contains real content (not just whitespace)
                    const hasRealContent = lines.some(line => line.trim() !== '');
                    if (hasRealContent) {
                        realEdits.push({
                            type: 'added',
                            lineStart: currentLine,
                            lineEnd: currentLine + lines.length - 1,
                            content: change.value
                        });
                    }
                    currentLine += lines.length;
                } else if (change.removed) {
                    // Check if the removal contains real content (not just whitespace)
                    const hasRealContent = lines.some(line => line.trim() !== '');
                    if (hasRealContent) {
                        realEdits.push({
                            type: 'removed',
                            lineStart: currentLine,
                            lineEnd: currentLine + lines.length - 1,
                            content: change.value
                        });
                    }
                    // Don't increment currentLine for removed content
                } else {
                    // Unchanged content
                    currentLine += lines.length;
                }
            }

            console.log("🔍 Real edits found:", realEdits);

            if (realEdits.length === 0) {
                console.log("✅ No real code changes detected (only whitespace changes)");
                return;
            }

            // Get current code chunks and steps
            const codeChunks = state.codeAwareSession.codeChunks;
            const steps = state.codeAwareSession.steps;
            const mappings = state.codeAwareSession.codeAwareMappings;

            // Find which code chunks are affected by real edits
            const affectedChunkIds = new Set<string>();

---

