<!-- Generated by SpecStory -->

# 更新代码块处理逻辑以支持逐行计算 (2025-08-12 00:42Z)

_**User**_

在调用llm进行MapCodeToSteps，由于LLM返回的代码块是以一行为一个字符串的字符串列表，在生成代码块的时候，应该逐行计算这行的代码位置，如果是连续的行，则合并成一个代码块，否则拆分成多个代码块存储，请你更新所有用到这部分的处理逻辑

---

_**Assistant**_

我需要查看现有的 MapCodeToSteps 相关代码，然后更新处理逻辑以支持按行计算代码位置并合并连续行。让我先查看相关的构造函数和处理逻辑。 现在我需要查看当前处理代码块映射的逻辑，然后更新以支持逐行处理和连续行合并。让我先看看现有的处理逻辑： 现在我需要实现一个新的辅助函数来处理逐行代码块的创建，并且支持连续行合并。让我创建这个函数并更新相关处理逻辑： 让我重新查找这个函数的确切位置： 现在我需要在这个函数之后添加新的辅助函数： 
```

```
现在我需要更新 MapCodeToSteps 处理逻辑，将原来直接合并字符串数组的方式改为使用新的辅助函数： 
```

```
我需要修复类型错误，现在更新代码块创建逻辑： 
```

```
我需要更新映射关系创建逻辑： 
```

```
现在我需要修复之前添加的类型错误，移除无效的codeLines属性： 
```

```
我需要修复变量重复声明的错误： 让我找到确切的代码位置： 
```

```
现在我需要更新代码块创建逻辑，使用stepsCodeLines变量： 
```

```
我需要确保stepsCodeLines变量在正确的作用域中可访问： 我需要将stepsCodeLines变量移出try-catch块，以便在后续使用： 
```

```
现在我还需要更新 `rerunStep` 函数以使用相同的逐行处理逻辑。让我找到这个函数： 现在我需要更新 `rerunStep` 函数中的映射处理逻辑： 
```

```
现在我需要更新 rerunStep 函数中的代码块创建逻辑： 
```

```
我需要更新映射关系创建逻辑以使用新的数据结构： 让我找到确切的代码段： [object Object]

---

_**User**_

@agent 继续: "是否继续迭代？"

---

_**Assistant**_


```

```
现在让我检查编译错误并修复它们： 太好了！现在所有编译错误都已经解决。让我简单验证一下代码的整体结构是否正确： 很好！新的辅助函数已经在两个地方被正确调用了。让我们测试一下新的功能是否能正常工作。先运行一下任务来编译代码： 完美！编译没有错误。现在让我总结一下我所做的更改：

## 总结

我已经成功更新了 CodeAware 系统中处理 MapCodeToSteps 的逻辑，以支持逐行代码块处理和连续行合并功能。以下是主要更改：

### 1. 新增辅助函数 `createCodeChunksFromLineArray`

**位置**: `/Users/thuzyh/Documents/hci/CodeAware/dev/CodeAware/gui/src/redux/thunks/codeAwareGeneration.ts:202-271`

**功能**:
- 接收字符串数组（LLM返回的逐行代码）
- 计算每行代码在完整代码中的位置
- 合并连续的代码行为一个代码块
- 为不连续的代码段创建多个独立的代码块
- 返回包含ID、内容和行号范围的代码块数组

### 2. 更新 `generateCodeFromSteps` 函数

**位置**: `/Users/thuzyh/Documents/hci/CodeAware/dev/CodeAware/gui/src/redux/thunks/codeAwareGeneration.ts:1680-1950`

**主要更改**:
- 保存LLM返回的原始行数组数据 (`stepsCodeLines`)
- 优先使用新的逐行处理逻辑创建代码块
- 回退到旧方式处理不兼容的数据格式
- 支持为每个步骤创建多个代码块（连续/不连续）
- 更新映射关系创建逻辑以支持多代码块

### 3. 更新 `rerunStep` 函数

**位置**: `/Users/thuzyh/Documents/hci/CodeAware/dev/CodeAware/gui/src/redux/thunks/codeAwareGeneration.ts:2170-2370`

**主要更改**:
- 应用相同的逐行处理逻辑
- 保存原始行数组用于后续处理
- 使用新的代码块创建和映射逻辑

### 4. 处理逻辑改进

**核心优势**:
1. **精确定位**: 每行代码都能准确定位到完整代码中的具体行号
2. **智能合并**: 连续的代码行自动合并为一个代码块，减少碎片化
3. **灵活拆分**: 不连续的代码段分离为独立代码块，保持逻辑清晰
4. **向后兼容**: 保留原有的整体代码块处理方式作为回退方案
5. **精确映射**: 每个代码块都有准确的行号范围 `[startLine, endLine]`

### 5. 数据流程

1. **LLM返回**: `code_snippets: ["line1", "line2", "line3", ...]`
2. **行号定位**: 在完整代码中找到每行的位置
3. **连续性分析**: 检查相邻行号是否连续
4. **代码块创建**: 
   - 连续行 → 单个代码块
   - 不连续行 → 多个代码块
5. **映射关系**: 为每个代码块创建与步骤/知识卡片的映射

这种新的处理方式能够更好地支持LLM返回的逐行代码数据，提供更精确的代码定位和更灵活的代码块管理，同时保持系统的稳定性和向后兼容性。

---

_**User**_

你可以去应用一下calculateCodeChunkRange的函数嘛？

---

_**Assistant**_



---

