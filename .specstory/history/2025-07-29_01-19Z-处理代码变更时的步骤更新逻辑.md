<!-- Generated by SpecStory -->

# å¤„ç†ä»£ç å˜æ›´æ—¶çš„æ­¥éª¤æ›´æ–°é€»è¾‘ (2025-07-29 01:19Z)

_**User**_

æˆ‘ç°åœ¨éœ€è¦å¤„ç†ä»codeEditorModeåˆ‡æ¢å›CodeAwareOnlyModeæ—¶çš„é€»è¾‘ï¼Œåœ¨processCodeChangeä¸­ï¼Œå½“æ£€æµ‹åˆ°æœ‰ä»£ç å®è´¨å˜æ›´ï¼Œå¹¶ä¸”æŠŠå¯¹åº”çš„stepè®¾ç½®æˆcode_dirtyåï¼ŒCodeAwareç•Œé¢åº”è¯¥æ ¹æ®æ˜¯å¦æœ‰ä»»ä½•æ­¥éª¤å¤„äºcode_dirtyçŠ¶æ€æ¥è®¾ç½®Loading Overlay. ç„¶åç»§ç»­processCodeChangesçš„é€»è¾‘ã€‚å¯¹äºcode_dirtyçš„æ­¥éª¤ï¼Œå°†æ­¥éª¤å’Œå…¶ä¸‹çš„çŸ¥è¯†å¡ç‰‡æ¶‰åŠçš„code_chunkséƒ½disableæ‰ï¼ŒæŠŠæ¶‰åŠè¿™éƒ¨åˆ†çš„mappingåˆ é™¤æ‰ã€‚åªè¦æœ‰ä»»ä½•æ­¥éª¤ä¸ºcode_dirtyï¼Œéƒ½éœ€è¦è°ƒç”¨ä¸€ä¸ªllmæ›´æ–°çš„thunksã€‚æ ·ä¾‹è¾“å…¥ä¸º{
   "current_code":"df = pd.read_csv(csv_filename)\n\nprint(\"æ•°æ®é›†æ¦‚è§ˆ:\")\nprint(\"\næ ‡ç­¾åˆ†å¸ƒ:\")\n print(df['label'].value_counts())\nprint(df.head())\n\n# åˆ é™¤åŒ…å«ä»»ä½•ç¼ºå¤±å€¼çš„è¡Œ\ndf.dropna(inplace=True)",
   "code_diff":"+ print("\næ ‡ç­¾åˆ†å¸ƒ:") + print(df['label'].value_counts())"
   "relevant_steps":[
       {
           "id":"s-2",
           "title":"æŸ¥çœ‹æ•°æ®çš„æ ·å¼",
           "abstract":"è¯»å…¥æ•°æ®åï¼Œå¯ä»¥å»æŸ¥çœ‹ä¸€ä¸‹æ•°æ®çš„æ ¼å¼å¹¶ä¿è¯è¯»å–æ­£ç¡®æ€§ã€‚ä½¿ç”¨ç­›é€‰è¡¨æ ¼å‰å‡ è¡Œçš„æ–¹æ³•ï¼ˆheadå‡½æ•°ï¼‰é‡‡æ ·è¡¨æ ¼æ•°æ®ï¼Œå¹¶æ‰“å°å‡ºæ¥"ï¼Œ
           "knowledge_cards":[{
               "id":"s-2-kc-1",
               "title":"æŸ¥çœ‹æ•°æ®è¡¨æ ¼çš„ç›®çš„"
           }]
}ï¼Œæ ·ä¾‹è¾“å‡ºä¸ºï¼š{
    "updated_steps":[{
         "id":"s-2",
        "needs_update":true,
         "title":"æŸ¥çœ‹æ•°æ®çš„æ ·å¼å’Œæ ‡ç­¾åˆ†å¸ƒ"ï¼Œ
         "abstract":"è¯»å…¥æ•°æ®åï¼Œå¯ä»¥å»æŸ¥çœ‹ä¸€ä¸‹æ•°æ®çš„æ ¼å¼å’Œæ ‡ç­¾çš„åˆ†å¸ƒæ¥åˆ¤æ–­æ•°æ®çš„è´¨é‡ã€‚ä½¿ç”¨ç­›é€‰è¡¨æ ¼å‰å‡ è¡Œçš„æ–¹æ³•ï¼ˆheadå‡½æ•°ï¼‰é‡‡æ ·è¡¨æ ¼æ•°æ®ï¼Œå¹¶æ‰“å°å‡ºæ¥ã€‚ç„¶åç”¨value_countsæ¥æ‰“å°è¡¨æ ¼ä¸­labelåˆ—çš„å–å€¼ç»Ÿè®¡",
         "corresponding_code":"df = pd.read_csv(csv_filename)\n\nprint(\"æ•°æ®é›†æ¦‚è§ˆ:\")\nprint(\"\næ ‡ç­¾åˆ†å¸ƒ:\")\n print(df['label'].value_counts())\nprint(df.head())\n\n# åˆ é™¤åŒ…å«ä»»ä½•ç¼ºå¤±å€¼çš„è¡Œ\ndf.dropna(inplace=True)"
     }],
         "knowledge_cards":[
             {
             "id":"s-2-kc-1",           "needs_update":true,
                 "title":"æŸ¥çœ‹æ•°æ®å–å€¼èŒƒå›´çš„ç›®çš„",         "corresponding_code":"print(df['label'].value_counts())"  
             }
         ]
}ã€‚è¿™ä¸ªthunkç”¨æ¥åˆ¤æ–­å‘ç”Ÿçš„æ›´æ”¹æ˜¯å¦è¦è°ƒæ•´ï¼Œè¾“å…¥ä¸ºæ›´æ–°åçš„ä»£ç ï¼Œcode diff(ç”¨diffå­—ç¬¦ä¸²å½¢å¼è¡¨ç¤º)ï¼Œä»¥åŠå‘ç”Ÿäº†ä¿®æ”¹çš„ç›¸å…³çš„æ­¥éª¤ä¿¡æ¯åˆ—è¡¨ï¼ŒåŒ…æ‹¬æ­¥éª¤idï¼Œæ­¥éª¤æ ‡é¢˜ï¼Œæ­¥éª¤æ‘˜è¦ï¼Œå…¶ä¸‹çš„çŸ¥è¯†å¡ç‰‡idå’Œæ ‡é¢˜ï¼Œè¾“å‡ºå†…å®¹åŒ…æ‹¬è¿™äº›æ­¥éª¤çš„æ˜¯å¦éœ€è¦æ›´æ–°çš„ä¿¡æ¯ï¼Œé€šè¿‡needs_updateè¡¨ç¤ºæ­¥éª¤çš„abstractå’Œknowledge contentæ˜¯å¦è¦æ›´æ–°ï¼ˆæ— è®ºæ˜¯å¦æ›´æ–°å†…å®¹éƒ½éœ€è¦åŒ…æ‹¬è¿›æ¥ï¼Œå› ä¸ºéœ€è¦æ›´æ–°å¯¹åº”çš„ä»£ç åŒºåŸŸï¼‰å¦‚æœæŸä¸ªstepå†…å®¹éœ€è¦æ›´æ–°ï¼Œåˆ™update titleå’Œabstractã€‚å¦‚æœæŸä¸ªknowledge card needs updateï¼Œåˆ™å°†titleæ›´æ–°å¥½åï¼Œå»æ‰åŸæ¥å¯èƒ½å·²ç”Ÿæˆçš„contentå’Œquestionä¿¡æ¯ã€‚å¹¶ä¸”æŒ‡å‡ºæ›´æ–°åçš„æ­¥éª¤/çŸ¥è¯†å¡ç‰‡å¯¹åº”çš„å½“å‰ä»£ç ï¼Œå‚è€ƒç”Ÿæˆä»£ç æ—¶è®¡ç®—ä»£ç ä½ç½®çš„æ–¹æ³•æ·»åŠ æ–°çš„code chunkå¹¶åˆ›å»ºmappingã€‚

---

_**Assistant**_

æˆ‘æ¥å¸®ä½ å®ç°ä»ä»£ç ç¼–è¾‘æ¨¡å¼åˆ‡æ¢å›CodeAwareæ¨¡å¼æ—¶çš„å®Œæ•´é€»è¾‘ã€‚é¦–å…ˆéœ€è¦æ·»åŠ æ–°çš„thunkæ¥å¤„ç†ä»£ç å˜æ›´çš„æ›´æ–°ï¼Œç„¶åä¿®æ”¹ç°æœ‰çš„`processCodeChanges`é€»è¾‘ã€‚

## 1. é¦–å…ˆæ·»åŠ æ–°çš„thunkæ¥å¤„ç†ä»£ç å˜æ›´æ›´æ–°

````typescript
// ...existing code...

// å¼‚æ­¥å¤„ç†ä»£ç å˜æ›´å¹¶æ›´æ–°ç›¸å…³æ­¥éª¤
export const updateStepsFromCodeChanges = createAsyncThunk<
    void,
    {
        currentCode: string;
        codeDiff: string;
        relevantSteps: Array<{
            id: string;
            title: string;
            abstract: string;
            knowledgeCards: Array<{
                id: string;
                title: string;
            }>;
        }>;
    },
    ThunkApiType
>(
    "codeAware/updateStepsFromCodeChanges",
    async (
        { currentCode, codeDiff, relevantSteps },
        { dispatch, extra, getState }
    ) => {
        try {
            const state = getState();
            const defaultModel = selectDefaultModel(state);
            if (!defaultModel) {
                throw new Error("Default model not defined");
            }

            console.log("updateStepsFromCodeChanges called with:", {
                currentCodeLength: currentCode.length,
                codeDiffLength: codeDiff.length,
                relevantStepsCount: relevantSteps.length,
                relevantSteps: relevantSteps.map(s => ({ id: s.id, title: s.title }))
            });

            // æ„é€ æç¤ºè¯
            const prompt = constructUpdateStepsFromCodeChangesPrompt(currentCode, codeDiff, relevantSteps);

            const result = await extra.ideMessenger.request("llm/complete", {
                prompt: prompt,
                completionOptions: {},
                title: defaultModel.title
            });

            if (result.status !== "success" || !result.content) {
                throw new Error("LLM request failed or returned empty content");
            }

            console.log("LLM response for code changes update:", result.content);

            // è§£æ LLM è¿”å›çš„ JSON å†…å®¹
            try {
                const jsonResponse = JSON.parse(result.content);
                const updatedSteps = jsonResponse.updated_steps || [];
                const knowledgeCards = jsonResponse.knowledge_cards || [];

                console.log("âœ… ä»£ç å˜æ›´æ›´æ–°æˆåŠŸ:", {
                    updatedStepsCount: updatedSteps.length,
                    knowledgeCardsCount: knowledgeCards.length
                });

                // è·å–å½“å‰çŠ¶æ€
                const currentState = getState();
                const currentFilePath = await getCurrentFilePath(extra.ideMessenger);
                const existingCodeChunksCount = currentState.codeAwareSession.codeChunks.length;
                let codeChunkCounter = existingCodeChunksCount + 1;

                // å¤„ç†æ›´æ–°çš„æ­¥éª¤
                for (const stepUpdate of updatedSteps) {
                    const stepId = stepUpdate.id;
                    
                    if (stepUpdate.needs_update) {
                        // æ›´æ–°æ­¥éª¤æ ‡é¢˜å’Œæ‘˜è¦
                        if (stepUpdate.title) {
                            dispatch(setStepTitle({ stepId, title: stepUpdate.title }));
                        }
                        if (stepUpdate.abstract) {
                            dispatch(setStepAbstract({ stepId, abstract: stepUpdate.abstract }));
                        }
                        
                        console.log(`ğŸ“ æ›´æ–°æ­¥éª¤ ${stepId}:`, {
                            title: stepUpdate.title,
                            abstract: stepUpdate.abstract?.substring(0, 100) + "..."
                        });
                    }

                    // å¤„ç†æ­¥éª¤å¯¹åº”çš„ä»£ç 
                    if (stepUpdate.corresponding_code && stepUpdate.corresponding_code.trim()) {
                        const stepCodeContent = stepUpdate.corresponding_code.trim();
                        const stepRange = calculateCodeChunkRange(currentCode, stepCodeContent);
                        const stepCodeChunkId = `c-${codeChunkCounter++}`;
                        
                        // åˆ›å»ºæ–°çš„ä»£ç å—
                        dispatch(createOrGetCodeChunk({
                            content: stepCodeContent,
                            range: stepRange,
                            filePath: currentFilePath,
                            id: stepCodeChunkId
                        }));

                        // æ‰¾åˆ°å¯¹åº”çš„éœ€æ±‚å—IDï¼ˆä»ç°æœ‰æ˜ å°„ä¸­æŸ¥æ‰¾ï¼‰
                        const existingStepMapping = currentState.codeAwareSession.codeAwareMappings.find(
                            mapping => mapping.stepId === stepId && mapping.requirementChunkId
                        );
                        const requirementChunkId = existingStepMapping?.requirementChunkId;

                        // åˆ›å»ºæ­¥éª¤æ˜ å°„
                        dispatch(createCodeAwareMapping({
                            codeChunkId: stepCodeChunkId,
                            stepId: stepId,
                            requirementChunkId: requirementChunkId,
                            isHighlighted: false
                        }));
                        
                        console.log(`ğŸ”— ä¸ºæ­¥éª¤ ${stepId} åˆ›å»ºæ–°ä»£ç å—: ${stepCodeChunkId} (${stepRange[0]}-${stepRange[1]}è¡Œ)`);
                    }
                }

                // å¤„ç†çŸ¥è¯†å¡ç‰‡æ›´æ–°
                for (const cardUpdate of knowledgeCards) {
                    const cardId = cardUpdate.id;
                    const stepId = cardId.split('-kc-')[0]; // ä»å¡ç‰‡IDæå–æ­¥éª¤ID
                    
                    if (cardUpdate.needs_update) {
                        // æ›´æ–°çŸ¥è¯†å¡ç‰‡æ ‡é¢˜å¹¶æ¸…ç©ºå†…å®¹
                        if (cardUpdate.title) {
                            dispatch(updateKnowledgeCardTitle({
                                stepId: stepId,
                                cardId: cardId,
                                title: cardUpdate.title
                            }));
                            
                            console.log(`ğŸ·ï¸ æ›´æ–°çŸ¥è¯†å¡ç‰‡ ${cardId} æ ‡é¢˜: "${cardUpdate.title}"`);
                        }
                    }

                    // å¤„ç†çŸ¥è¯†å¡ç‰‡å¯¹åº”çš„ä»£ç 
                    if (cardUpdate.corresponding_code && cardUpdate.corresponding_code.trim()) {
                        const cardCodeContent = cardUpdate.corresponding_code.trim();
                        const cardRange = calculateCodeChunkRange(currentCode, cardCodeContent);
                        const cardCodeChunkId = `c-${codeChunkCounter++}`;
                        
                        // åˆ›å»ºæ–°çš„ä»£ç å—
                        dispatch(createOrGetCodeChunk({
                            content: cardCodeContent,
                            range: cardRange,
                            filePath: currentFilePath,
                            id: cardCodeChunkId
                        }));

                        // æ‰¾åˆ°å¯¹åº”çš„éœ€æ±‚å—ID
                        const existingCardMapping = currentState.codeAwareSession.codeAwareMappings.find(
                            mapping => mapping.knowledgeCardId === cardId
                        );
                        const requirementChunkId = existingCardMapping?.requirementChunkId;

                        // åˆ›å»ºçŸ¥è¯†å¡ç‰‡æ˜ å°„
                        dispatch(createCodeAwareMapping({
                            codeChunkId: cardCodeChunkId,
                            stepId: stepId,
                            knowledgeCardId: cardId,
                            requirementChunkId: requirementChunkId,
                            isHighlighted: false
                        }));
                        
                        console.log(`ğŸ¯ ä¸ºçŸ¥è¯†å¡ç‰‡ ${cardId} åˆ›å»ºæ–°ä»£ç å—: ${cardCodeChunkId} (${cardRange[0]}-${cardRange[1]}è¡Œ)`);
                    }
                }

                // å°†æ‰€æœ‰å¤„ç†è¿‡çš„æ­¥éª¤çŠ¶æ€ä» code_dirty æ”¹ä¸º confirmed
                const processedStepIds = updatedSteps.map(step => step.id);
                for (const stepId of processedStepIds) {
                    dispatch(setStepStatus({ stepId, status: "confirmed" }));
                }

                console.log("âœ… ä»£ç å˜æ›´æ›´æ–°å®Œæˆ");

            } catch (parseError) {
                console.error("Error parsing LLM response:", parseError);
                throw new Error("è§£æLLMå“åº”å¤±è´¥");
            }

        } catch (error) {
            console.error("Error during code changes update:", error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new Error(`ä»£ç å˜æ›´æ›´æ–°å¤±è´¥: ${errorMessage}`);
        }
    }
);

// è¾…åŠ©å‡½æ•°ï¼šè·å–å½“å‰æ–‡ä»¶è·¯å¾„
async function getCurrentFilePath(ideMessenger: any): Promise<string> {
    try {
        const currentFileResponse = await ideMessenger.request("getCurrentFile", undefined);
        if (currentFileResponse?.status === "success" && currentFileResponse.content) {
            return currentFileResponse.content.path || "";
        }
    } catch (error) {
        console.warn("âš ï¸ æ— æ³•è·å–å½“å‰æ–‡ä»¶è·¯å¾„:", error);
    }
    return "";
}

// ...existing code...
````

## 2. æ·»åŠ æ„é€ æç¤ºè¯çš„å‡½æ•°ï¼ˆéœ€è¦åœ¨core/llm/codeAwarePromptsä¸­æ·»åŠ ï¼‰

ä½ éœ€è¦åœ¨coreåŒ…ä¸­æ·»åŠ è¿™ä¸ªå‡½æ•°ï¼š

````typescript
// ...existing code...

export function constructUpdateStepsFromCodeChangesPrompt(
    currentCode: string,
    codeDiff: string,
    relevantSteps: Array<{
        id: string;
        title: string;
        abstract: string;
        knowledgeCards: Array<{
            id: string;
            title: string;
        }>;
    }>
): string {
    return `ä½ æ˜¯ä¸€ä¸ªä»£ç å­¦ä¹ åŠ©æ‰‹ã€‚ç”¨æˆ·åœ¨ä»£ç ç¼–è¾‘å™¨ä¸­ä¿®æ”¹äº†ä»£ç ï¼Œç°åœ¨éœ€è¦ä½ åˆ†æè¿™äº›å˜æ›´æ˜¯å¦å½±å“ç›¸å…³çš„å­¦ä¹ æ­¥éª¤å’ŒçŸ¥è¯†å¡ç‰‡ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„æ›´æ–°ã€‚

## å½“å‰å®Œæ•´ä»£ç ï¼š
\`\`\`
${currentCode}
\`\`\`

## ä»£ç å˜æ›´ï¼ˆdiffæ ¼å¼ï¼‰ï¼š
\`\`\`
${codeDiff}
\`\`\`

## å—å½±å“çš„ç›¸å…³æ­¥éª¤ï¼š
${relevantSteps.map(step => `
### æ­¥éª¤ ${step.id}
- æ ‡é¢˜: ${step.title}
- æ‘˜è¦: ${step.abstract}
- çŸ¥è¯†å¡ç‰‡:
${step.knowledgeCards.map(kc => `  - ${kc.id}: ${kc.title}`).join('\n')}
`).join('\n')}

## ä»»åŠ¡è¦æ±‚ï¼š
è¯·åˆ†æä»£ç å˜æ›´å¯¹è¿™äº›æ­¥éª¤çš„å½±å“ï¼Œå¹¶è¿”å›JSONæ ¼å¼çš„æ›´æ–°ä¿¡æ¯ï¼š

1. å¯¹äºæ¯ä¸ªæ­¥éª¤ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°å…¶æ ‡é¢˜å’Œæ‘˜è¦
2. å¯¹äºæ¯ä¸ªçŸ¥è¯†å¡ç‰‡ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°å…¶æ ‡é¢˜
3. ä¸ºæ¯ä¸ªæ­¥éª¤å’ŒçŸ¥è¯†å¡ç‰‡ç¡®å®šå…¶å¯¹åº”çš„ä»£ç ç‰‡æ®µ

## è¿”å›æ ¼å¼ï¼š
\`\`\`json
{
    "updated_steps": [
        {
            "id": "æ­¥éª¤ID",
            "needs_update": true/false,
            "title": "æ›´æ–°åçš„æ ‡é¢˜ï¼ˆå¦‚æœéœ€è¦æ›´æ–°ï¼‰",
            "abstract": "æ›´æ–°åçš„æ‘˜è¦ï¼ˆå¦‚æœéœ€è¦æ›´æ–°ï¼‰",
            "corresponding_code": "è¯¥æ­¥éª¤å¯¹åº”çš„ä»£ç ç‰‡æ®µ"
        }
    ],
    "knowledge_cards": [
        {
            "id": "çŸ¥è¯†å¡ç‰‡ID", 
            "needs_update": true/false,
            "title": "æ›´æ–°åçš„æ ‡é¢˜ï¼ˆå¦‚æœéœ€è¦æ›´æ–°ï¼‰",
            "corresponding_code": "è¯¥çŸ¥è¯†å¡ç‰‡å¯¹åº”çš„ä»£ç ç‰‡æ®µ"
        }
    ]
}
\`\`\`

æ³¨æ„äº‹é¡¹ï¼š
- å³ä½¿ä¸éœ€è¦æ›´æ–°å†…å®¹ï¼Œä¹Ÿè¦åŒ…å«åœ¨ç»“æœä¸­ï¼Œå› ä¸ºéœ€è¦æ›´æ–°ä»£ç å¯¹åº”å…³ç³»
- å¦‚æœä»£ç å˜æ›´è¾ƒå°ä¸”ä¸å½±å“æ­¥éª¤æœ¬è´¨ï¼Œå¯ä»¥è®¾ç½® needs_update ä¸º false
- corresponding_code åº”è¯¥æ˜¯ä»å½“å‰å®Œæ•´ä»£ç ä¸­æå–çš„ç›¸å…³ç‰‡æ®µ
- æ›´æ–°çš„æ ‡é¢˜å’Œæ‘˜è¦åº”è¯¥å‡†ç¡®åæ˜ ä»£ç å˜æ›´
`;
}

// ...existing code...
````

## 3. ä¿®æ”¹processCodeChangeså‡½æ•°

````typescript
// ...existing code...

// Process code changes when exiting code edit mode
export const processCodeChanges = createAsyncThunk<
    void,
    {
        currentFilePath: string;
        currentContent: string;
    },
    ThunkApiType
>(
    "codeAware/processCodeChanges",
    async ({ currentFilePath, currentContent }, { getState, dispatch }) => {
        try {
            const state = getState();
            const snapshot = state.codeAwareSession.codeEditModeSnapshot;
            
            if (!snapshot) {
                console.warn("No code snapshot found, cannot process changes");
                return;
            }

            // Check if we're working on the same file
            if (snapshot.filePath !== currentFilePath) {
                console.warn("File path changed, processing changes might not be accurate");
            }

            // Import diff library dynamically to avoid bundling issues
            const { diffLines } = await import('diff');
            
            // Calculate diff between snapshot and current content
            const changes = diffLines(snapshot.content, currentContent);
            
            console.log("ğŸ“Š Code changes detected:", {
                totalChanges: changes.length,
                additions: changes.filter(c => c.added).length,
                deletions: changes.filter(c => c.removed).length
            });

            // Track real edits (excluding whitespace-only changes)
            const realEdits: Array<{
                type: 'added' | 'removed' | 'modified';
                lineStart: number;
                lineEnd: number;
                content: string;
            }> = [];

            let currentLine = 1;
            
            for (const change of changes) {
                if (!change.value) continue;
                
                const lines = change.value.split('\n');
                // Remove last empty line if it exists
                if (lines[lines.length - 1] === '') {
                    lines.pop();
                }
                
                if (change.added) {
                    // Check if the addition contains real content (not just whitespace)
                    const hasRealContent = lines.some(line => line.trim() !== '');
                    if (hasRealContent) {
                        realEdits.push({
                            type: 'added',
                            lineStart: currentLine,
                            lineEnd: currentLine + lines.length - 1,
                            content: change.value
                        });
                    }
                    currentLine += lines.length;
                } else if (change.removed) {
                    // Check if the removal contains real content (not just whitespace)
                    const hasRealContent = lines.some(line => line.trim() !== '');
                    if (hasRealContent) {
                        realEdits.push({
                            type: 'removed',
                            lineStart: currentLine,
                            lineEnd: currentLine + lines.length - 1,
                            content: change.value
                        });
                    }
                    // Don't increment currentLine for removed content
                } else {
                    // Unchanged content
                    currentLine += lines.length;
                }
            }

            console.log("ğŸ” Real edits found:", realEdits);

            if (realEdits.length === 0) {
                console.log("âœ… No real code changes detected (only whitespace changes)");
                return;
            }

            // Get current code chunks and steps
            const codeChunks = state.codeAwareSession.codeChunks;
            const steps = state.codeAwareSession.steps;
            const mappings = state.codeAwareSession.codeAwareMappings;

            // Find which code chunks are affected by real edits
            const affectedChunkIds = new Set<string>();

---

